# 동시성 제어 방식

트랜잭션 간 연산의 순서를 제어하여 일관성의 훼손 없이 동시 실행을 가능하게 하는 기법이 필요한데, 이를 동시성 제어라고한다. 

데이터의 일관성을 유지하면서도 동시에 실행될 수 있는 트랜잭션의 수를 늘릴 수 있는 기법을 말한다.



## 락 기반 규약

락 기반 규약은 각 데이터 항목마다 락(Lock)을 두고 각 트랜잭션이 일정한 규칙인 락킹 프로토콜에 맞추어 락을 획득하고 반납하도록 규정하는 기법을 말한다.

- 공유 락 : 트랜잭션 T가 데이터 항목 Q에 공유하는 형태의 락을 얻으면 → S로 표기, 트랜잭션 T는 데이터 항목 Q를 읽을 수는 있으나 쓸 수는 없다.
- 배타 락 : 트랜잭션 T가 데이터 항목에 Q에 대한 배타 형태의 락을 얻으면 → X로 표기, 트랜잭션 T는 데이터 항목 Q를 읽고 쓸 수 있다.

락 기반 규약을 사용하는 시스템에서 모든 트랜잭션은 데이터 항목 Q에 실행할 연산 종류에 따라 동시성 제어 관리 모듈에 공유 또는 배타 락을 요청하고 획득해야만 연산을 진행할 수 있다.

공유 락은 다른 공유 락과 양립할 수 있지만 배타 락과는 양립할 수 없다.

특정 데이터에 대한 공유 락은 서로 다른 트랜잭션에 의해 동시에 소유될 수 있다.

양립될 수 없는 락 요청은 먼저 락을 소유한 트랜잭션이 락을 반납할때까지 기다려야 한다.

**데이터에 락을 요청/반납하는 명령**

- LS(Q) : 데이터 Q에 대한 공유 락을 요청
- LX(Q) : 데이터 Q에 대한 배타 락을 요청
- UN(Q) : 데이터 Q에 대한 공유/배타 락을 반납

**트랜잭션이 락을 사용하는 방법**

- 데이터에 대한 접근이 끝난 직후에 데이터에 대한 락을 바로 반납하는 방법
- 트랜잭션이 데이터에 접근하고 있는 동안에는 그 데이터에 대한 락을 계속 소유하고 있는 방법



### 2단계 락킹 규약

직렬성을 보장하는 규약. 각 트랜잭션이 락을 요청할 수 있는 확장 단계와 락을 반납할 수만 있는 축소 단계로 구성

- 확장 단계 : 트랜잭션이 락을 얻을 수는 있으나 락을 반납할 수 없는 단계
- 축소 단계 :  트랜잭션이 락을 반납할 수는 있으나 새로운 락을 얻을 수 없는 단계

트랜잭션이 획득한 락 중 하나라도 반납하게 되면 그 순간 트랜잭션은 축소 단계로 전환되며 이때부터는 더 이상 락 요청을 할 수 없다.

2단계 락킹 규약의 사용 목적은 직렬성을 보장하는 것.\

교착상태를 예방할 수는 없다.




### 엄격한 2단계 락킹 규약

트랜잭션이 모든 락을 유지하다가 커밋이 되거나 중단될 경우에만 락을 해지한다.

- 트랜잭션 T가 Read(A) 연산을 수행하면 시스템은 해당 읽기 연산에 대하여 락을 설정
- T가 Write(A) 연산을 수행하면 시스템은 T가 A에 공유 락을 보유하고 있는지 확인
    - 공유 락을 보유하고 있으면 배타 락으로 전환
    - 공유 락을 보유하고 있지 않으면 A에 대하여 배타 학을 설정
- T에 의하여 얻어진 모든 락은 해당 트랜잭션이 커밋 되거나 중단되면 해지된다.

모든 트랜잭션이 커밋을 하는 순서로 직렬성이 보장된다.




## 타임스탬프 기반 규약

직렬성 순서를 결정하는 또 다른 방법은 트랜잭션 간의 순서를 미리 선택하는 것



### 타임 스탬프를 할당하는 방법

- 시스템 클럭 : 트랜잭션의 타임스탬프를 그 트랜잭션이 시스템으로 들어 올 때의 시스템 클럭 값으로 설정
- 논리적 계수기 :  새로운 타임스탬프가 발급될 때마다 증가되는 논리적 계수기의 값으로 설정



### 토마스 기록 규칙

- 타임스탬프 순서 규약을 일부 수정하여 원래의 타임스탬프 순서 규약보다 더 높은 덩시성을 제공할 수 있다.
- 수정된 타임스탬프 순서 규약을 토마스의 기록 규칙이라고 한다.
- 트랜잭션에서 무의미한 Write 연산을 제고하는 방법으로 직렬성을 제공
- 다른 규약으로는 생성할 수 없는 직렬 스케쥴을 생성할 수 있다.
